# 在现有项目中工作：完整指南

> **强烈推荐：使用 Gemini Web 或 Gemini CLI 生成现有项目文档！**
>
> Gemini Web 超过一百万 token 的上下文窗口或 Gemini CLI（在能正常使用时）可以一次性分析您的整个代码库或其关键部分（当然是在合理范围内）：
>
> - 通过 GitHub URL 上传，或在项目文件夹中使用 gemini cli
> - 如果在 Web 环境中工作：使用 `npx bmad-method flatten` 将您的项目“扁平化”为一个单文件，然后将该文件上传到您的 Web 代理。

## 什么是现有项目（Brownfield）开发？

现有项目（Brownfield）开发指的是为已有的软件项目添加功能、修复错误或进行现代化改造。与全新项目（Greenfield）不同，现有项目的工作需要理解已有代码、尊重现有约束，并确保新变更能够无缝集成，而不会破坏现有功能。

## 何时为现有项目使用 BMad

- 为现有应用程序添加重要新功能
- 对遗留代码库进行现代化改造
- 集成新技术或服务
- 重构复杂系统
- 修复需要理解架构的错误
- 为未文档化的系统创建文档

## 何时不应使用现有项目工作流

如果您刚用 BMad 完成了一个最小可行产品（MVP），并希望继续进行 MVP 后的开发，更简单的方法是直接与项目经理（PM）沟通，让它与您协作创建一个新的史诗（epic）并添加到产品需求文档（PRD）中，然后将史诗分片，与架构师一起更新任何相关的架构文档，然后继续开发。

## 完整的现有项目工作流

1.  **遵循[<ins>用户指南 - 安装</ins>](user-guide.zh-CN.md#installation)中的步骤，在 Web 环境中设置您的代理。**
2.  **生成一个包含您整个代码库的“扁平化”单文件**，运行：`npx bmad-method flatten`

### 选择您的方法

#### 方法 A：PRD 优先（推荐用于添加非常庞大和复杂的新功能、单个或多个史诗或大规模变更）

**最适用于**：大型代码库、单一代码仓库（monorepos），或者当您确切知道要构建什么时

1.  **首先创建 PRD** 来定义需求
2.  **仅根据 PRD 需求** 记录相关区域的文档
3.  **更高效** - 避免为未使用的代码编写文档

#### 方法 B：文档优先（适用于较小项目）

**最适用于**：较小的代码库、未知的系统或探索性变更

1.  **首先为整个系统编写文档**
2.  **在拥有完整上下文的情况下创建 PRD**
3.  **更全面** - 捕获所有内容

### 方法 A：PRD 优先工作流（推荐）

#### 阶段一：首先定义需求

**在 Gemini Web 中（已上传您的 flattened-codebase.xml）：**

```bash
@pm
*create-brownfield-prd
```

项目经理（PM）将会：

-   **询问您关于增强功能**的需求
-   **探索代码库**以了解当前状态
-   **识别需要文档化**的受影响区域
-   **创建范围明确**的、重点突出的 PRD

**关键优势**：PRD 能识别出您的单一代码仓库（monorepo）/大型代码库中哪些部分真正需要文档化！

#### 阶段二：重点文档化

**仍在 Gemini Web 中，现在带有 PRD 上下文：**

```bash
@architect
*document-project
```

分析师将会：

-   如果没有提供 PRD，**询问您的关注点**
-   **提供选项**：创建 PRD、提供需求或描述增强功能
-   **参考 PRD/描述**来理解范围
-   **专注于 PRD 或您描述中**确定的相关模块
-   **跳过不相关的区域**以保持文档精简
-   为所有环境**生成一份架构文档**

分析师创建：

-   **一份全面的架构文档**，遵循 `fullstack-architecture` 模板
-   **在单个文件中涵盖**所有系统方面
-   **易于复制和保存**为 `docs/project-architecture.md`
-   如果需要，**之后可以在 IDE 中进行分片**

例如，如果您说“为用户服务添加支付处理功能”：

-   仅记录：用户服务、API 端点、数据库模式、支付集成
-   创建仅显示与支付相关的代码路径的重点源码树
-   跳过：管理面板、报告模块、不相关的微服务

### 方法 B：文档优先工作流

#### 阶段一：为现有系统编写文档

**最佳方法 - 使用具有 1M+ 上下文的 Gemini Web**：

1.  **访问 Gemini Web** (gemini.google.com)
2.  **上传您的项目**：
    -   **选项 A**：直接粘贴您的 GitHub 仓库 URL
    -   **选项 B**：上传您的 `flattened-codebase.xml` 文件
3.  **加载分析师代理**：上传 `dist/agents/architect.txt`
4.  **运行文档化**：输入 `*document-project`

分析师将为所有内容生成全面的文档。

#### 阶段二：规划您的增强功能

##### 选项 A：完整的现有项目工作流（推荐用于重大变更）

**1. 创建现有项目 PRD**：

```bash
@pm
*create-brownfield-prd
```

项目经理（PM）代理将会：

-   **分析阶段一中**的现有文档
-   **向您请求具体的增强功能细节**
-   **评估复杂性**并推荐方法
-   为增强功能**创建史诗/用户故事结构**
-   **识别风险和集成点**

**项目经理代理如何获取项目上下文**：

-   在 Gemini Web 中：已经从阶段一的文档中获得了完整的项目上下文
-   在 IDE 中：会询问“请提供您现有项目文档的路径”

**您会遇到的关键提示**：

-   “您想添加什么具体的增强功能或特性？”
-   “这需要与任何现有系统或 API 集成吗？”
-   “我们必须遵守哪些关键约束？”
-   “您的时间表和团队规模是怎样的？”

**2. 创建现有项目架构**：

```bash
@architect
*create-brownfield-architecture
```

架构师将会：

-   **审查现有项目 PRD**
-   **设计集成策略**
-   如果需要，**规划迁移方法**
-   **识别技术风险**
-   **定义兼容性要求**

##### 选项 B：快速增强（用于重点变更）

**对于没有完整 PRD 的单个史诗**：

```bash
@pm
*create-brownfield-epic
```

使用场景：

-   增强功能定义明确且独立
-   现有文档全面
-   变更不影响多个系统
-   您需要快速周转

**对于单个用户故事**：

```bash
@pm
*create-brownfield-story
```

使用场景：

-   修复错误或微小功能
-   非常孤立的变更
-   无架构影响
-   实现路径清晰

### 阶段三：验证规划产物

```bash
@po
*execute-checklist-po```

产品负责人（PO）确保：

-   与现有系统的兼容性
-   没有计划中的破坏性变更
-   风险缓解策略已到位
-   集成方法清晰

### 阶段四：保存和分片文档

1.  将您的 PRD 和架构文档另存为：
    `docs/brownfield-prd.md`
    `docs/brownfield-architecture.md`
2.  分片您的文档：
    在您的 IDE 中

    ```bash
    @po
    shard docs/brownfield-prd.md
    ```

    ```bash
    @po
    shard docs/brownfield-architecture.md
    ```

### 阶段五：过渡到开发

**遵循[<ins>增强版 IDE 开发工作流</ins>](enhanced-ide-development-workflow.zh-CN.md)**

## 现有项目最佳实践

### 1. 始终先文档化

即使您认为自己了解代码库：

-   运行 `document-project` 以捕获当前状态
-   AI 代理需要此上下文
-   发现未文档化的模式

### 2. 尊重现有模式

现有项目模板专门寻找：

-   当前的编码约定
-   现有的架构模式
-   技术约束
-   团队偏好

### 3. 计划逐步推出

现有项目的变更应：

-   支持功能标志
-   规划回滚策略
-   包含迁移脚本
-   保持向后兼容性

### 4. 彻底测试集成

测试重点在于：

-   集成点
-   现有功能（回归测试）
-   性能影响
-   数据迁移

### 5. 沟通变更

记录：

-   变更内容及其原因
-   迁移说明
-   引入的新模式
-   弃用通知

## 常见的现有项目场景

### 场景一：添加新功能

1.  为现有系统编写文档
2.  创建专注于集成的现有项目 PRD
3.  架构强调兼容性
4.  用户故事包含集成任务

### 场景二：现代化遗留代码

1.  广泛的文档化阶段
2.  PRD 包含迁移策略
3.  架构计划逐步过渡
4.  用户故事遵循“绞杀者无花果”模式

### 场景三：修复复杂系统中的错误

1.  为相关子系统编写文档
2.  使用 `create-brownfield-story` 进行重点修复
3.  包含回归测试要求
4.  QA 验证无副作用

### 场景四：API 集成

1.  为现有 API 模式编写文档
2.  PRD 定义集成要求
3.  架构确保模式一致
4.  用户故事包含 API 文档更新

## 故障排除

### “AI 不理解我的代码库”

**解决方案**：使用更具体的关键文件路径重新运行 `document-project`

### “生成的计划不符合我们的模式”

**解决方案**：在规划阶段之前，用您的特定约定更新生成的文档

### “对于小变更来说，模板过于繁琐”

**解决方案**：使用 `create-brownfield-story` 而不是完整的工作流

### “集成点不清晰”

**解决方案**：在创建 PRD 期间提供更多上下文，特别突出集成系统

## 快速参考

### 现有项目特定命令

```bash
# 为现有项目编写文档
@architect → *document-project

# 创建增强功能 PRD
@pm → *create-brownfield-prd

# 创建以集成为重点的架构
@architect → *create-brownfield-architecture

# 快速创建史诗
@pm → *create-brownfield-epic

# 创建单个用户故事
@pm → *create-brownfield-story
```

### 决策树

```text
您是否有一个大型代码库或单一代码仓库？
├─ 是 → PRD 优先方法
│   └─ 创建 PRD → 仅为受影响区域编写文档
└─ 否 → 您是否熟悉该代码库？
    ├─ 是 → PRD 优先方法
    └─ 否 → 文档优先方法

这是一个影响多个系统的重大增强功能吗？
├─ 是 → 完整的现有项目工作流
└─ 否 → 这不仅仅是一个简单的错误修复吗？
    ├─ 是 → brownfield-create-epic
    └─ 否 → brownfield-create-story
```

## 结论

使用 BMad-Method 进行现有项目开发，为修改现有系统提供了结构和安全性。关键在于通过文档提供全面的上下文，使用考虑集成需求的专用模板，并遵循尊重现有约束同时又能推动进展的工作流。

请记住：**先文档化，仔细规划，安全集成**